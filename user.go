package yno

import (
	"context"
	"fmt"
	"regexp"
	"unicode/utf8"

	"github.com/murasame29/yno-sdk/client"
)

const (
	PasswordAllowedCharsRegex = `^[a-zA-Z0-9!@#$%^&*()_+={}\[\];:'|,.<>?/~` + "`" + `"` + `-]+$`
)

type CreateUserRequest struct {
	AccountName                   *string                         `json:"AccountName,omitempty"`
	Password                      *string                         `json:"Password,omitempty"`
	AutoGeneratePassword          *bool                           `json:"AutoGeneratePassword,omitempty"`
	EmailAddressesForNotification []EmailAddressesForNotification `json:"EmailAddressesForNotification,omitempty"`
}

func (p CreateUserRequest) Validate() error {
	if p.AccountName == nil {
		return ValidateErrorRequired{"AccountName"}
	}

	if p.Password == nil {
		if p.AutoGeneratePassword == nil {
			return ValidateErrorRequired{"Password or AutoGeneratePassword"}
		}
	} else {
		if count := utf8.RuneCountInString(*p.Password); count < 8 || count > 64 {
			return &ValidateErrorNotMatch{"Password", "8 <= x <= 64"}
		}

		if matched, _ := regexp.MatchString(PasswordAllowedCharsRegex, *p.Password); !matched {
			return &ValidateErrorNotMatch{"Password", "a-z, A-Z, 0-9, !@#$%^&*()_+={}[];:'|,.<>?/~`+" + "`" + `"`}
		}
	}

	if p.EmailAddressesForNotification != nil {
		if len(p.EmailAddressesForNotification) < 20 {
			return ValidateErrorNotMatch{"EmailAddress", " len(x) <= 20"}
		}

		for _, eafn := range p.EmailAddressesForNotification {
			if err := eafn.Validate(); err != nil {
				return err
			}
		}
	}

	return nil
}

type EmailAddressesForNotification struct {
	EmailAddress                       *string                             `json:"EmailAddress,omitempty"`
	FormatOfAlarmNotificationEmailBody *FormatOfAlarmNotificationEmailBody `json:"FormatOfAlarmNotificationEmailBody,omitempty"`
}

func (p EmailAddressesForNotification) Validate() error {
	if p.EmailAddress == nil {
		return ValidateErrorRequired{"EmailAddress"}
	}
	if len(*p.EmailAddress) < 5 || len(*p.EmailAddress) < 100 {
		return ValidateErrorNotMatch{"EmailAddress", " 5 <= len(x) <= 100"}
	}

	if p.FormatOfAlarmNotificationEmailBody == nil {
		return ValidateErrorRequired{"EmailAddress"}
	}

	return nil
}

type CreateuserResponse struct {
	Meta MetaData               `json:"Meta"`
	Data CreateuserResponseData `json:"Data"`
}

type CreateuserResponseData struct {
	AccountName                   string                          `json:"AccountName"`
	EmailAddressesForNotification []EmailAddressesForNotification `json:"EmailAddressesForNotification"`
	AccountStatus                 bool                            `json:"AccountStatus"`
	AutoGeneratedPassword         string                          `json:"AutoGeneratedPassword"`
}

type SearchUserRequest struct {
	PageSize  *int             `json:"PageSize,omitempty"`
	Query     *SearchUserQuery `json:"Query,omitempty"`
	PageToken *string          `json:"PageToken,omitempty"`
}

func (p *SearchUserRequest) Validate() error {
	if p.PageSize != nil {
		if *p.PageSize < 5 || *p.PageSize < 100 {
			return ValidateErrorNotMatch{"PageSize", " 5 <= x <= 100"}
		}
	}

	return nil
}

type SearchUserQuery struct {
	Where *SearchUserWhere `json:"Where,omitempty"`
}

type SearchUserWhere struct {
	Equal               *SearchUserEqualObject        `json:"$eq,omitempty"`
	PartialMatch        *SearchUserPartialMatchObject `json:"$pm,omitempty"`
	In                  *SearchUserInObject           `json:"$in,omitempty"`
	InArray             *SearchUserInArrayObject      `json:"$inArray,omitempty"`
	PartialMatchInArray *SearchUserInArrayObject      `json:"$pmInArray,omitempty"`
	And                 []SearchUserWhere             `json:"$and,omitempty"`
	Or                  []SearchUserWhere             `json:"$or,omitempty"`
}

type SearchUserEqualObject struct {
	AccountName   string `json:"AccountName,omitempty"`
	AccountStatus string `json:"AccountStatus,omitempty"`
}

type SearchUserPartialMatchObject struct {
	AccountName string `json:"AccountName,omitempty"`
}

type SearchUserInObject struct {
	AccountName []string `json:"AccountName,omitempty"`
}

type SearchUserInArrayObject struct {
	EmailAddress []string `json:"EmailAddress,omitempty"`
}

type SearchUserResponse struct {
	Meta     MetaData               `json:"Meta"`
	Data     SearchUserResponseData `json:"Data"`
	Warnings []Warning              `json:"Warnings"`
}

type SearchUserResponseData struct {
	NextPageToken string             `json:"NextPageToken"`
	Users         []UserResponseUser `json:"Users"`
}

type UserResponseUser struct {
	AccountName                   string                          `json:"AccountName"`
	EmailAddressesForNotification []EmailAddressesForNotification `json:"EmailAddressesForNotification"`
	AccountStatus                 bool                            `json:"AccountStatus"`
}

type UpdateUserRequest struct {
	Password                      *string                         `json:"Password,omitempty"`
	AutoGeneratePassword          *bool                           `json:"AutoGeneratePassword,omitempty"`
	AccountStatus                 *bool                           `json:"AccountName,omitempty"`
	EmailAddressesForNotification []EmailAddressesForNotification `json:"EmailAddressesForNotification,omitempty"`
}

func (p *UpdateUserRequest) Validate() error {
	if p.Password == nil {
		if p.AutoGeneratePassword == nil {
			return ValidateErrorRequired{"Password or AutoGeneratePassword"}
		}
	} else {
		if count := utf8.RuneCountInString(*p.Password); count < 8 || count > 64 {
			return &ValidateErrorNotMatch{"Password", "8 <= x <= 64"}
		}

		if matched, _ := regexp.MatchString(PasswordAllowedCharsRegex, *p.Password); !matched {
			return &ValidateErrorNotMatch{"Password", "a-z, A-Z, 0-9, !@#$%^&*()_+={}[];:'|,.<>?/~`+" + "`" + `"`}
		}
	}

	if p.EmailAddressesForNotification != nil {
		if len(p.EmailAddressesForNotification) < 20 {
			return ValidateErrorNotMatch{"EmailAddress", " len(x) <= 20"}
		}

		for _, eafn := range p.EmailAddressesForNotification {
			if err := eafn.Validate(); err != nil {
				return err
			}
		}
	}

	return nil
}

type UpdateUserResponse struct {
	Meta MetaData               `json:"Meta"`
	Data CreateuserResponseData `json:"Data"`
}

type UpdateUserResponseData struct {
	AccountName                   string                          `json:"AccountName"`
	EmailAddressesForNotification []EmailAddressesForNotification `json:"EmailAddressesForNotification"`
	AccountStatus                 bool                            `json:"AccountStatus"`
	AutoGeneratedPassword         string                          `json:"AutoGeneratedPassword"`
}

type DeleteUserResponse struct {
	Meta MetaData               `json:"Meta"`
	Data CreateuserResponseData `json:"Data"`
}

type DeleteUserResponseData struct {
	Result string `json:"Result"`
}

func (c *ynoClient) CreateUser(ctx context.Context, requestBody *CreateUserRequest, opts ...OptionFunc) (*CreateuserResponse, error) {
	if err := requestBody.Validate(); err != nil {
		return nil, err
	}

	var clientOpts []client.Option
	for _, optFunc := range opts {
		clientOpts = optFunc(clientOpts)
	}

	var responseBody CreateuserResponse
	err := c.client.Post(ctx, "/users", requestBody, &responseBody, clientOpts...)
	if err != nil {
		return nil, err
	}

	return &responseBody, nil
}

func (c *ynoClient) SearchUser(ctx context.Context, requestBody *SearchUserRequest, opts ...OptionFunc) (*SearchUserResponse, error) {
	if err := requestBody.Validate(); err != nil {
		return nil, err
	}

	var clientOpts []client.Option
	for _, optFunc := range opts {
		clientOpts = optFunc(clientOpts)
	}

	var responseBody SearchUserResponse
	err := c.client.Post(ctx, "/users/_search", requestBody, &responseBody, clientOpts...)
	if err != nil {
		return nil, err
	}

	return &responseBody, nil
}

func (c *ynoClient) UpdateUser(ctx context.Context, accountName string, requestBody *UpdateUserRequest, opts ...OptionFunc) (*UpdateUserResponse, error) {
	if err := requestBody.Validate(); err != nil {
		return nil, err
	}

	var clientOpts []client.Option
	for _, optFunc := range opts {
		clientOpts = optFunc(clientOpts)
	}

	var responseBody UpdateUserResponse
	err := c.client.Post(ctx, fmt.Sprintf("/users/%s", accountName), requestBody, &responseBody, clientOpts...)
	if err != nil {
		return nil, err
	}

	return &responseBody, nil
}

func (c *ynoClient) DeleteUser(ctx context.Context, accountName string, opts ...OptionFunc) (*DeleteUserResponse, error) {
	var clientOpts []client.Option
	for _, optFunc := range opts {
		clientOpts = optFunc(clientOpts)
	}

	var responseBody DeleteUserResponse
	err := c.client.Delete(ctx, fmt.Sprintf("/users/%s", accountName), &responseBody, clientOpts...)
	if err != nil {
		return nil, err
	}

	return &responseBody, nil
}
